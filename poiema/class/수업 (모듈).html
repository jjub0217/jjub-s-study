<!-- // 모듈의 목표 : 독립적인 모듈들을 만들어서 조립해서 애플리케이션을 만들자.
// 백엔드의 모듈 기반언어는 클래스다. 
// 프론트의 모듈은, 어떤 단위의 언어가 모듈인가?
// 클라이언트에서 모듈을 어떤것을 모듈이라고 할건가? html 도 잇고 css 도 있고 js도 잇잖아. 그래서 프론트에서의 모듈은 원래 어려운거였다. 
// 뷰 리액트 앵귤러 등 컴퍼넌트 라는게 모듈의 단위다.( 컴퍼넌트 베이스드 디벨롭 : 컴퍼넌트를 기반으로 한다)

// 그럼 컴퍼넌트는 뭐냐? html css js 의 집합을 컴퍼넌트라고 한다. 
// 모듈 : 컴퍼넌트보다 작은 단위다.(재사용이 가능한 것)
// 모듈이나 컴퍼넌트를 만든다는 것은 재사용하기 위한다는 의미이다.


// 모듈: 기본적으로 파일 단위다.
// 스크립트 태그로 여러개 js 파일을 html 에 모아놓는다고 해도 이건 전역을 공유하는 것이기 때문에
// 결국 파일을 나눈게 아니다. 모듈화를 한게 아니라는 의미이다.
// 그런데, ES6 에서 모듈화를 지원하기 시작했다지만 아직까지도 불안정하다. 



// ES6 에서 지원하는 모듈화의 키워드

// 1. import(수입) : 받아온다
//      - 외부에서 받아올때 사용 (필요한것들만)
//      - require 키워드가 js 의 독자적인 모듈이다.
// 2. export(수출) : 내보낸다  
// 3. default : 이름없이 내보낼때 사용 (무조건 하나만 내보낸다.) -->


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script type="module" src="/수업(모듈)foo.mjs"></script>
    <script type="module" src="/수업(모듈)bar.mjs"></script>
    <!-- └> 얘 자체적인 스포크를 갖기 시작한다. -->


    <!-- <script src="foo.js"></script>  -->
    <!-- <script src="bar.js"></script> -->
    <!-- 이러면 파일을 나눈다해도 나눈게 아니라는 의미이다.
    이러면 var 로 선언한 변수를 못찾는다. 모듈화 한 파일에 선언한 변수가 
    전역이 아니라 지역변수화 된다.  -->
</body>
</html>